第 1 章   引言  	10
    1.1  什么是设计模式  	11
    1.2 Smalltalk MVC 中的设计模式  	12
    1.3  描述设计模式  	13
    1.4  设计模式的编目  	14
    1.5  组织编目  	16
    1.6  设计模式怎样解决设计问题  	17
        1.6.1  寻找合适的对象  	17
        1.6.2  决定对象的粒度  	18
        1.6.3  指定对象接口  	18
        1.6.4  描述对象的实现  	19
        1.6.5  运用复用机制  	22
        1.6.6  关联运行时刻和编译时刻的结构  	24
        1.6.7  设计应支持变化  	25
    1.7  怎样选择设计模式  	28
    1.8  怎样使用设计模式  	29
第 2 章   实例研究：设计一个文档编辑器  	31
    2.1  设计问题  	32
    2.2  文档结构  	32
        2.2.1  递归组合  	33
        2.2.2  图元  	34
        2.2.3  组合模式  	36
    2.3  格式化  	36
        2.3.1  封装格式化算法  	36
        2.3.2 Compositor 和 Composition  	36
        2.3.3  策略模式  	38
    2.4  修饰用户界面  	38
        2.4.1  透明围栏  	38
        2.4.2 Monoglyph  	39
        2.4.3 Decorator  模式  	41
    2.5  支持多种视感标准  	41
        2.5.1  对象创建的抽象  	41
        2.5.2  工厂类和产品类  	42
        2.5.3 Abstract Factory 模式  	44
    2.6  支持多种窗口系统  	44
        2.6.1  我们是否可以使用 Abstract Factory 模式  	44
        2.6.2  封装实现依赖关系  	44
        2.6.3 Window 和 WindowImp  	46
        2.6.4 Bridge  模式  	49
    2.7  用户操作  	49
        2.7.1  封装一个请求  	50
        2.7.2 Command  类及其子类  	50
        2.7.3  撤消和重做  	51
        2.7.4  命令历史记录  	51
        2.7.5 Command  模式  	53
    2.8  拼写检查和断字处理  	53
        2.8.1  访问分散的信息  	53
        2.8.2  封装访问和遍历  	54
        2.8.3 Iterator 类及其子类  	55
        2.8.4 Iterator 模式  	57
        2.8.5  遍历和遍历过程中的动作  	57
        2.8.6  封装分析  	57
        2.8.7 Visitor  类及其子类  	60
        2.8.8 Visitor  模式  	61
    2.9  小结  	62
第 3 章   创建型模式  	63
    3.1 Abstract Factory （抽象工厂）对象创建型模式  	66
    3.2 Builder （生成器）—对象创建型模式  	72
    3.3 Factory Method （工厂方法）—对象创建型模式  	79
    3.4 Prototype （原型）—对象创建型模式  	96
    3.5 Singleton （单件）—对象创建型模式  	93
    3.6  创建型模式的讨论  	98
第 4 章   结构型模式  	100
    4.1 Adapter （适配器）—类对象结构型模式  	101
    4.2 Bridge （桥接）—对象结构型模式  	109
    4.3 Composite （组成）—对象结构型模式  	116
    4.4 Decorator （装饰）—对象结构型模式  	124
    4.5 FACADE （外观）—对象结构型模式  	130
    4.6 Flyweight （享元）—对象结构型模式  	137
    4.7 Proxy （代理）—对象结构型模式  	146
    4.8  结构型模式的讨论  	153
        4.8.1 Adapter 与 Bridge  	153
        4.8.2 Composite 、 Decorator 与 Proxy  	154
第 5 章   行为模式  	156
    5.1 CHAIN OF RESPONSIBIL ITY （职责链）—对象行为型模式  	156
    5.2 COMMAND （命令）—对象行为型模式  	163
    5.3 INTERPRETER （解释器）—类行为型模式  	171
    5.4 ITERATOR （迭代器）—对象行为型模式  	180
    5.5 MEDIATOR （中介者）—对象行为型模式  	190
    5.6 MEMENTO （备忘录）—对象行为型模式  	197
    5.7 OBSERVER （观察者）—对象行为型模式  	203
    5.8 STATE （状态）—对象行为型模式  	210
    5.9 STRATEGY （策略）—对象行为型模式  	217
    5.10 TEMPLATE METHOD （模板方法）模式  	227
    5.11 VISITOR （访问者）—对象行为型模式  	227
    5.12  行为模式的讨论  	237
        5.12 1  封装变化  	237
        5.12.2  对象作为参数  	237
        5.12.3  通信应该被封装还是被分布  	238
        5.12.4  对发送者和接收者解耦  	238
        5.12.5  总结  	240
第 6 章   结论  	241
    6.1  设计模式将带来什么  	241
    6.2  一套通用的设计词汇  	241
    6.3  书写文档和学习的辅助手段  	241
    6.4  现有方法的一种补充  	242
    6.5  重构的目标  	242
    6.6  本书简史  	243
    6.7  模式界  	244
    6.8 Alexander  的模式语言  	244
    6.9  软件中的模式  	245
    6.10  邀请参与  	246
    6.11  临别感想  	246
附录 A  词汇表  	247
附录 B  图示符号指南  	250
附录 C  基本类  	253
参考文献  	258
